<!DOCTYPE html>
<meta charset="utf-8">

<style type="text/css">

</style>
<body>
</body>


<script src="https://d3js.org/d3.v5.min.js"></script>
<script>

// Configurações basicas do SVG
var margin = {top: 50, right: 50, bottom: 50, left: 50}
  , width = 481
  , height = 275;

// Numero de pontos
var n = 21;

// Escalas do x e y
var xScale = d3.scaleLinear()
    .range([0, width]);
var yScale = d3.scaleLinear()
    .range([height, 0]);
var countryXScale = d3.scaleLinear()
  .range([0, width]);
var countryYScale = d3.scaleLinear()
  .range([height, 0]);

 // define promise para que a função para gerar o mapa só seja executada após a leitura dos arquivos
 var promises = [];

          // contem número de alianças de cada país
 promises.push(d3.csv('data/nodes.csv'));               // nós do grafo
 promises.push(d3.csv('data/edges.csv'));        // grafo contendo relação entre países em cada conflito

var edges, conflicts = [], conflictsByYear = [], countriesConflicts = {};

 // executa a função "ready" após leitura dos arquivos
 Promise.all(promises)
    .then(ready)
    .catch(function(error){
      throw error;
    });

 // gera o mapa e seus elementos
 function ready(data) {

    edges = d3.nest()
   .key(function(d) { return d.conflict.trim();}).sortKeys(d3.ascending)
   .entries(data[1].filter(function(d){ return d.relation === "-";}));   // pega as relações de conflito

   // somatorio de conflitos por ano
   data[0].forEach(function(d){
      countriesConflicts[d.id] = [];
      for(var i = 1500; i <= 2018; i++){
         countriesConflicts[d.id].push({year:i, amount:0});
      }
   });

   edges.forEach(function(conflict){
      end = conflict.values[0].end.trim();
      if(end === "Ongoing"){
         conflicts.push({source:conflict.values[0].source_id , target:conflict.values[0].target_id, conflict:conflict.key, start:+conflict.values[0].start, end:end});
      }else{
         conflicts.push({source:conflict.values[0].source_id , target:conflict.values[0].target_id, conflict:conflict.key, start:+conflict.values[0].start, end:+end});
      }
   });
   // Ano inicial e final dos dados
   startYear = 1501;
   currentYear = 2018;

   duration = []
   // Duracao dos conflitos, caso seja Ongoing (ainda acontecendo) usa 2018
   conflicts.forEach(function(d) {
      if(d.end === "Ongoing"){
         duration.push({conflict:d.conflict, duration: currentYear - d.start});
      }else{
         duration.push({conflict:d.conflict, duration: d.end - d.start});
      }
   });
   duration.sort(function(x, y){ return +x.duration < +y.duration ? 1 : -1;});

   var i;

   for(i = 0; i <= currentYear - startYear; i++){
      conflictsByYear.push({year:startYear+i,conflicts:0});
   }


   conflicts.forEach(function(conflict){
      start = conflict.start;
      if(conflict.end == "Ongoing"){
         while(start <= currentYear){
            countriesConflicts[conflict.source][start-startYear].amount++;
            countriesConflicts[conflict.target][start-startYear].amount++;
            conflictsByYear[start-startYear].conflicts++;
            start++;
         }
      }else{
         while(start <= conflict.end){
            countriesConflicts[conflict.source][start-startYear].amount++;
            countriesConflicts[conflict.target][start-startYear].amount++;
            conflictsByYear[start-startYear].conflicts++;
            start++;
         }
      }
   });



   xScale.domain([1500, 2018]);
   yScale.domain([0, d3.max(conflictsByYear, function(d){ return +d.conflicts})]);

   // Gera as linhas da serie
    var line = d3.line()
        .x(function(d) { return xScale(d.year); })
        .y(function(d) { return yScale(d.conflicts); })
        .curve(d3.curveMonotoneX)

        var line1 = d3.line()
           .x(function(d) { return xScale(d.year); })
           .y(function(d) { return yScale(d.amount); })
           .curve(d3.curveMonotoneX)

    // Coloca o SVG na pagina
    var svg = d3.select("body").append("svg")
        .attr("width", width + margin.left + margin.right)
        .attr("height", height + margin.top + margin.bottom)
      .append("g")
        .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

    // Eixo X
    svg.append("g")
        .attr("class", "x axis")
        .attr("transform", "translate(0," + height + ")")
        .call(d3.axisBottom(xScale).ticks(10));

    // Eixo Y
    svg.append("g")
        .attr("class", "y axis")
        .call(d3.axisLeft(yScale));

    // Linhas
    svg.append("path")
        .datum(conflictsByYear)
        .attr("class", "line")
        .attr("d", line);

        svg.append("path")
           .datum(countriesConflicts['BRA'])
           .attr("class", "line1")
           .attr("d", line1);

    // 12. Appends a circle for each datapoint
    // svg.selectAll(".dot")
    //     .data(conflictsByYear)
    //   .enter().append("circle") // Uses the enter().append() method
    //     .attr("class", "dot") // Assign a class for styling
    //     .attr("cx", function(d) { return xScale(d.year) })
    //     .attr("cy", function(d) { return yScale(d.conflicts) })
    //     .attr("r", 3)
    //       .on("mouseover", function(d) {
    //   			console.log(d)
    //         // this.attr('class', 'focus')
    // 		})
    //       .on("mouseout", function() {  })
    //       .on("mousemove", mousemove);
    //
    //   var focus = svg.append("g")
    //       .attr("class", "focus")
    //       .style("display", "none");
    //
    //   focus.append("circle")
    //       .attr("r", 4.5);
    //
    //   focus.append("text")
    //       .attr("x", 9)
    //       .attr("dy", ".35em");
    //
    //   svg.append("rect")
    //       .attr("class", "overlay")
    //       .attr("width", width)
    //       .attr("height", height)
    //       .on("mouseover", function() { focus.style("display", null); })
    //       .on("mouseout", function() { focus.style("display", "none"); })
    //       .on("mousemove", mousemove);
    //
    //   function mousemove() {
    //     var x0 = x.invert(d3.mouse(this)[0]),
    //         i = bisectDate(data, x0, 1),
    //         d0 = data[i - 1],
    //         d1 = data[i],
    //         d = x0 - d0.date > d1.date - x0 ? d1 : d0;
    //     focus.attr("transform", "translate(" + x(d.date) + "," + y(d.close) + ")");
    //     focus.select("text").text(d);
    //   }
}
</script>
